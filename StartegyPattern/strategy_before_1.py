'''Время от времени вы можете оказаться в положении, когда вам захочется переключаться
между различными способами решения проблемы. По сути, вы хотите иметь возможность выбирать
стратегию во время выполнения, а затем работать с ней. Каждая стратегия может иметь свой
собственный набор сильных и слабых сторон. Предположим, вы хотите свести два значения к
одному значению. Предполагая , что эти значения являются числовыми значениями,
у вас есть несколько вариантов их уменьшения.

В качестве примера рассмотрим использование простого сложения и вычитания в качестве
 стратегий сокращения двух чисел.
  Давайте назовем их arg1 и arg2.
   Простым решением было бы что-то вроде этого:'''

def reducer(arg1, arg2, strategy=None):
    if strategy == "addition":
        print(arg1 + arg2)
    elif strategy == "subtraction":
        print(arg1 - arg2)
    else:
        print("Strategy not implemented ..")

def main():
    reducer(4, 6)
    reducer(4, 6, "addition")
    reducer(4, 6, "subtraction")


if __name__ == '__main__':
    main()

'''К сожалению, мы сталкиваемся с той же проблемой,а именно: всякий раз, когда мы хотим 
добавить другую стратегию в редуктор, нам приходится добавлять в функцию еще один оператор elif вместе
с другим блоком кода для обработки этой стратегии. 
Это верный способ вырастить пространное утверждение if.
Мы бы предпочли более модульное решение, которое позволило бы нам передавать новые
стратегии на лету без необходимости изменять код, который использует или выполняет
стратегию.
'''